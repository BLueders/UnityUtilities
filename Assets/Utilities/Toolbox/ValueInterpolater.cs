//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections.Generic;

public class ValueInterpolater : MonoBehaviour {

    private const string GAME_OBJECT_NAME = "ValueInterpolater";

    public enum InterpType { 
        LINEAR,
        ACCELERATE, 
        DECELERATE, 
        ACCELERATE_DECELERATE, 
        ANTICIPATE, 
        OVERSHOOT, 
        ANTICIPATE_OVERSHOOT 
    }

    private static Dictionary<InterpType, InterpFunction> sDelegates;

    static ValueInterpolater() {
        sDelegates = new Dictionary<InterpType, InterpFunction>();
    
        sDelegates.Add(InterpType.LINEAR, Linear);
        sDelegates.Add(InterpType.ACCELERATE, Accelerate);
        sDelegates.Add(InterpType.DECELERATE, Decelerate);
        sDelegates.Add(InterpType.ACCELERATE_DECELERATE, AccelerateDecelerate);
        sDelegates.Add(InterpType.ANTICIPATE, Anticipate);
        sDelegates.Add(InterpType.OVERSHOOT, Overshoot);
        sDelegates.Add(InterpType.ANTICIPATE_OVERSHOOT, AnticipateOvershoot);
    }

    public Action<float> OnTick;

    [SerializeField]
    private bool active;

    [SerializeField]
    float duration, delay;

    [SerializeField]
    float start, end;

    [SerializeField]
    float coefficient;

    [SerializeField]
    float t;

    private delegate float InterpFunction(float t, float T);

    private InterpFunction interpFunction;

    public static ValueInterpolater LerpValueInterpolated(InterpType type, float coefficient, float start, float end, float duration, float delay, Action<float> callback) {
        GameObject instance = new GameObject();
        instance.name = GAME_OBJECT_NAME;

        ValueInterpolater interpolater = instance.AddComponent<ValueInterpolater>();

        interpolater.interpFunction = sDelegates[type];
        interpolater.coefficient = coefficient;
        interpolater.start = start;
        interpolater.end = end;
        interpolater.duration = duration;
        interpolater.delay = delay;
        interpolater.OnTick = callback;

        interpolater.Start();

        return interpolater;
    }
        

    void Update() {
        if (active) {
            if (delay > 0f) {
                delay -= Time.deltaTime;
            } else {
                Progress();
            }
        }
    }

    public void SkipDelay() {
        delay = 0f;
    }

    public void SkipToEnd() {
        End();
    }

    public void Cancel() {
        active = false;
        Destroy(this.gameObject);
    }

    /// <summary>
    /// Begin interpolation.
    /// </summary>
    private void Start() {
        t = 0f;
        active = true;
        Tick(0f);
    }
        
    private void Progress() {
        t += Time.deltaTime / duration;

        if (t < 1f) {
            Tick(interpFunction(t, coefficient));
        } else {
            End();
        }
    }

    /// <summary>
    /// End of interpolation.
    /// </summary>
    private void End() {
        active = false;
        Tick(1f);
        Destroy(this.gameObject);
    }

    /// <summary>
    /// Perform one tick with the interpolated t value
    /// </summary>
    /// <param name="t">Current t value</param>
    private void Tick(float t) {
        float value = Normalize(start, end, t);
        if (OnTick != null) OnTick(value);
    }

    /// <summary>
    /// 0-1 Normalize the value t between min and max
    /// </summary>
    /// <param name="min">Minimum.</param>
    /// <param name="max">Max.</param>
    /// <param name="t">T.</param>
    private float Normalize(float min, float max, float t) {
        return (max - min) * t + min;
    }


    // Interpolation delegate methods

    public static float Linear(float t, float T) {
        return t;
    }

    public static float AccelerateDecelerate(float t, float T) {
        return Mathf.Cos((t + 1f) * Mathf.PI) / 2f + .5f;
	}
	
    public static float Accelerate(float t, float T) {
        return Mathf.Pow(t, 2f * T);
	}

    public static float Decelerate(float t, float T) {
        return 1f - Mathf.Pow(1f - t, 2f * T);
    }

    public static float Anticipate(float t, float T) {
        return (T + 1f) * Mathf.Pow(t, 3f) - T * Mathf.Pow(t, 2f);
    }

    public static float Overshoot(float t, float T) {
        return (T + 1f) * Mathf.Pow(t - 1f, 3f) + T * Mathf.Pow(t - 1f, 2f) + 1f;
    }

    public static float AnticipateOvershoot(float t, float T) {
        if (t < .5f) {
            return .5f * ((T + 1f) * Mathf.Pow(2f * t, 3f) - T * Mathf.Pow(2f * t, 2f));
        } else {
            return .5f * ((T + 1f) * Mathf.Pow(2f * t - 2f, 3f) + T * Mathf.Pow(2f * t - 2f, 2f)) + 1f;
        }
    }
}